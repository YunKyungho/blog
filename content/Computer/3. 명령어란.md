컴퓨터는 명령어를 처리하는 기계다.

우리가 프로그래밍을 할 때 작성하는 모든 소스 코드는 컴퓨터에게 내리는 명령어의 집합과도 같다.

이번엔 이 명령어에 대해서 알아보자.

  

**목차**

1. **저급 언어,** **고급 언어**

2. **명령어의 구조**

3. **주소 지정 방식**

4. 

---

#### 저급 언어, 고급 언어

명령어에 대해 알아보기 전에 꼭 짚고 넘어가야할 개념이다.

  

컴퓨터가 이해할 수 있는 언어는 오직 저급언어뿐이다. 우리가 C, C++, C#, Java, Python, 등과 같은 프로그래밍 언어로 작성한 소스 코드는 컴퓨터가 이해하기 위해선 저급언어로 **변환**되어야만 한다.

#### 저급언어

- **기계어**

컴퓨터가 이해할 수 있는 것은 오로지 0과 1뿐이었다. 명령어도 예외는 없다.

0과 1로만 이루어진 명령어를 우리는 **기계어**라고 부른다.

(0과 1로만 작성되어있으면 가독성이 떨어지기에 16진수로 표현한다는데 사람에게 이게 의미가 있나 싶다.)

  

- **어셈블리어**

앞서 기계어에서 컴퓨터가 이해할 수 있는 것은 0과 1밖에 없다면서 어셈블리어는 어떻게 컴퓨터가 이해할 수 있는가?

그 0과 1로 이루어진 명령어들을 문자 집합 처럼 1 대 1로 대응 시켜 놓은 것이 어셈블리어다.

  

고급언어도 읽기 힘들구만 무슨 저급언어를 쓰겠어라는 생각이 들수도 있지만

하드웨어와 밀접하게 맞닿아 있는 프로그램들의 개발자는 사용한다고 한다.

#### 고급언어

2진수, 16진수(기계어), 어셈블리어 뭐가 됐던 쉽게 읽히는 놈들은 아닌 것 같다.

그래서 나온 것들이 우리가 아는 C, Java, Python, 등등의 언어들이다. (이 중에서도 C언어는 좀 더 날 것에 가깝다.)

  

앞에서 고급언어는 저급언어로 **변환**되어야만 한다고 했었는데 이 변환 방식에 따라 언어를 나눠볼 수 있다.

(정확히는 딱 나눌 수 있는게 아니긴 하다.)

  

- **컴파일 언어**

소스 코드를 실행 하기 전 코드 전체를 저급 언어로 변환한 뒤 실행 되는 언어다. 이 변환 과정을 **컴파일(compile)**이라고 하며 이 컴파일을 수행해주는 도구를 **컴파일러(compiler)**라고 한다. 이 컴파일 과정에서 컴파일러가 소스 코드내의 오류를 찾는다면 컴파일에 실패한다. 따라서 실행 전에 문법 오류를 발견할 수 있다. 이렇게 저급언어로 변환된 소스코드를 **목적코드**라고 부른다.

  

- **인터프리터 언어**

소스 코드를 한 줄씩 차례대로 저급 언어로 변환한 뒤 실행하는 언어이다. 이때 사용되는 도구가 **인터프리터(interpreter)**다. 소스 코드 전체가 저급 언어로 변환되는 시간을 기다릴 필요가 없으며 한 줄씩 변환하기에 프로그램이 작동 하다가 문법 오류가 발생한다.

  

컴파일 시간이 없으니 인터프리터 언어가 빠를 것 같지만 한줄 씩 변환해야되기에 일반적으로 컴파일 언어가 더 빠르다고 한다. 그리고 실행전 문법 오류를 발견할 수 있고 없고의 차이도 요즘 IDE들의 기능이 좋아서 큰 의미는 없는 것 같다.

  

컴파일 언어와 인터프리터 언어에 각각 해당하는 언어를 따로 기재하지 않은 이유는 앞서 말했 듯이 정확히 딱 나눌 수 있는 개념은 아니기 때문이다. 인터프리터 언어라고 컴파일 하지 않는 것이 아니고 컴파일 언어라고 해서 인터프리트를 수행하지 않는 것이 아니다.

  

중요한 것은 자신이 사용하는 언어가 저급 언어로 변환될 때 어떤 방식을 통해 변환 되는지를 아냐 모르냐다.

(각 언어 마다 작동 방식의 차이점이 있고 이를 탐구하는 것은 나에게는 꽤나 재밌는 일로 다가왔었다.)

---

#### 명령어의 구조

  

명령어는 **연산 코드**와 **오퍼랜드**로 구성돼있다. **연산자**와 **피연산자**라고도 부른다.

  

사람의 명령조를 생각 해보자. "방 좀 치워라!"라는 말이 있다면 "치워라"가 연산이고 "방"이 데이터다.

|   |   |
|---|---|
|치워라|방|

컴퓨터에게 명령을 내리는 것도 똑같은 구조다. "1945번지의 값을 숫자 5와 더해라"라는 명령어는

|   |   |   |
|---|---|---|
|더해라|1945번지 값|5|

여기서 빨간 글씨가 연산 코드고 검은 글씨가 오퍼랜드다.

풀어서 말하자면 **연산코드**는 **명령어가 수행할 연산**, **오퍼랜드**는 **연산에 사용할 데이터** 혹은 **데이터가 저장된 위치**다.

그리고 연산 코드가 담긴 영역은 **연산 코드 필드**, 오퍼랜드가 담긴 영역은 **오퍼랜드 필드**라고 부른다고 한다.

  

- **오퍼랜드**

오퍼랜드에는 연산에 사용할 데이터 혹은 메모리나 레지스터 주소가 올 수 있다.

일반적으로 데이터를 **직접 명시하기 보단 주소 값**을 쓴다. 그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.

  

오퍼랜드의 갯수는 0 ~ n개 존재한다. 없을 수도 있을 수도 많을 수도 있다.

명령어를 오퍼랜드의 갯수에 따라 'n-주소 명령어'라고 부른다. (0개면 0-주소 명령어, 1개면 1-주소 명령어)

  

- **연산 코드**

연산코드는 명령어가 수행할 연산을 의미한다.

매우 많은 연산 코드가 존재하며 기본적인 유형은 크게 네 가지로 나눌 수 있다.

  

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

각 명령어를 굳이 적어놓진 않을 것이다. 어떤 내용인지만 대략 알고 넘어가자.

- 데이터 전송 : CPU 내부 혹은 CPU와 메모리간의 데이터 저장, 읽기 작업에 대한 명령어
- 산술/논리 연산 : 프로그래밍 언어를 배워봤다면 알 것이다. +, -, *, /, >, <, =, !=, &, | 같은 명령어.
- 제어 흐름 변경 : 함수 호출 혹은 반복문을 사용했을 때 컴퓨터 내부적으로는 특정 주소로 실행 순서를 옮기게 되는데 그러한 작업들을 하는 명령어.
- 입출력 제어 : 입출력 장치와 통신하는 명령어.

---

#### 주소 지정 방식

오퍼랜드에 값을 넣을 때 일반적으로 저장된 위치의 주소 값을 명시한다고 했었는데 이는 명령어의 크기 때문이다.

  

총 명령어의 크기가 정해져있고 남은 용량을 n개의 오퍼랜드가 나눠가진다면 표현할 수 있는 데이터의 크기가 한정되기 때문에 메모리 혹은 레지스터의 위치를 명시함으로써 데이터의 표현 범위를 늘리는 것이다.

  

이때 데이터가 저장된 위치를 **유효 주소**라고 하며 이 유효 주소를 찾는 방법이 곧 **주소 지정 방식**이다.

  

- **즉시 주소 지정 방식** : 연산에 사용할 데이터를 오퍼랜드에 직접 명시하는 방식.  
      
    
- **직접 주소 지정 방식** : 유효 주소를 오퍼랜드에 직접 명시하는 방식.  
      
    
- **간접 주소 지정 방식** : 유효 주소의 주소를 오퍼랜드에 명시하는 방식.  
    (메모리에 접근을 2번 하기에 좀 더 느리지만 표현 가능한 주소 범위가 더 넓어진다.)  
      
    
- **레지스터 주소 지정 방식** : 데이터를 저장한 레지스터를 오퍼랜드에 명시하는 방식.  
    (메모리에 접근 하지 않고 CPU 내부에서만 작동하기에 더 빠르다.)  
      
    
- **레지스터 간접 주소 지정 방식** : 데이터는 메모리에 저장하고 이의 주소(유효주소)를 저장한 레지스터를 오퍼랜드에 명시하는 방식. (간접 주소 지정 방식과 비슷하나 메모리에 접근을 1번만 하기에 더욱 빠르다.)