[[6. Unit conversion(State)]]

이 글 밑에 부분에서 진행 했던 방법이 인지는 못했지만 isolation과 encapsulation을 적용 시켜서 모든 JSX를 분리된 컴포넌트로 만들었는데 이와 같은 방법을 이용하면 분할 해서 정복할 수 있다는 큰 장점이 있다. 이는 우리가 로직을 갖는 컴포넌트를 만들게 해주고 원하는 만큼 이 것들을 재사용할 수도 있게 된다.

다만 여러가지 로직들과 index 역할을 하는 로직이 하나의 파일에 전부 들어있다는 것은 과하다는 생각이 들수 있다. 그렇기에 별개의 로직들을 고립시켜서 분리된 컴포넌트로 만들고 이런 자식 컴포넌트를 Rendering하는 큰 부모 컴포넌트를 만들어 나갈 것이다.

비록 부모 컴포넌트의 로직 보다 더욱 큰 로직을 가진 컴포넌트라고 할지라도 말이다. 그리고 이 부모 컴포넌트를 우린 App이라고 부를 것이다.

Props는 일종의 방식이다. 부모 컴포넌트로부터 자식 컴포넌트에게 데이터를 보낼 수 있게 해주는 방법이다. 다만 Props를 배우기 위해선 Props로 해결이 가능하게 될 문제들을 먼저 겪어 봐야 한다.

하나의 앱에는 여러가지 버튼이 있을 것이고 이것을 동일하게 디자인 하는 것이 디자이너들의 일일 것이다. 그런데 우리는 하나의 컴포넌트를 재사용하는 방법을 모르기에 그 각각의 버튼을 전부 한번씩 만든다고 생각 해보자.

```python
function SaveBtn(){
	return <button>Save Changes</button>;
}
function ConfirmBtn(){
	return <button>Confirm</button>;
}
function App(){
	return (
		<div>	
			<SaveBtn />
			<ConfirmBtn />
		</div>
);
}
```

이런식으로 어떤 로직을 가진 버튼 컴포넌트를 만들고 그걸 App에서 render 해주고

(위의 버튼 함수를 함수형 컴포넌트라고 부르며 App에 return 값을 JSX의 내부라고 부른다.)

위에서 버튼에 style을 부여한다고 생각하면 style에 Js객체 형태로 이것저것 값을 넣고 이제 그걸 그대로 복사해서 다른 버튼에도 넣어주는 식일텐데 이 모종의 설정들을 넘겨 줄 수 있는 button 컴포넌트가 있다면 얼마나 좋을까?

App이라는 부모 컴포넌트에서 자식 컴포넌트를 호출할 때 일반적인 함수 처럼 property를 넣어줄 수 있다. 그리고 그 property는 호출 되는 자식 컴포넌트에서 첫번째 인자로 받게 되는데 이를 사람들은 props이라고 부른다. (두번째 인자는 없으며 props가 전달 받는 유일한 인자이다.)

```jsx
// 자식 컴포넌트
function Btn(props){
	return <button
			style={{
					속성,
					속성
				}}
		>props.text</button>;
}

// 부모 컴포넌트
function App(){
	return (
		<div>	
			<Btn text="Save Changes"/>
			<Btn text="Confirm"/>
		</div>
);
}
```

위 소스가 그의 예시다.

Btn에서 넘겨줄 property의 이름은 어떻게 지어도 아무런 상관이 없으며 자식 컴포넌트에서 받는 props는 객체 형태이다. 이름을 apple로 지었다면 [props.apple](http://props.apple) 이렇게 값을 가져오기만 하면 된다.

그런데 어차피 props는 객체이기 때문에 그냥 props로 받는 것이 아니라

```jsx
// 자식 컴포넌트
function Btn({apple}){
	return <button
			style={{
					속성,
					속성
				}}
		>{apple}</button>;
}
```

이렇게 중괄호를 열어 넘겨줬던 이름 그대로 사용하는 것이 가능하다.

물론 apple 보다는 그냥 text로 이름을 짓는 것이 나을 것 같다.

또한 상위 컴포넌트에서 여러가지 property를 보냈다면 {text, 뭐, 뭐} 이런식으로 전부 받아서 사용이 가능하다. 그리고 이는 String 뿐만아니라 true, false, 함수 까지 전부 보낼 수 있다.

그렇다면 부모 컴포넌트에서 state를 변경할 때 어떤 일이 일어날까?

이를 알아보기 위해 부모 컴포넌트에서 onclick 함수를 만들어볼 것이다.

```jsx
// 자식 컴포넌트
function Btn({text, onClick}){
	return <button
			onclick = {onClick}
			style={{
					속성,
					속성
				}}
		>props.text</button>;
}

// 부모 컴포넌트
function App(){
	const [value, setValue] = React.useState("Save Changes");
	const changeValue = () => setValue("Revert Changes");
	return (
		<div>	
			<Btn text={value} onClick={changeValue}/>
			// 위 onClick은 실제 이벤트리스너가 아니라 prop 이름일 뿐이고 Btn으로 전달될 뿐이다.
			// 위의 자식 컴포넌트 Btn에서 onClick을 받아야지만 진짜 이벤트 리스너가 되는 것이다.
			<Btn text="Confirm"/>
		</div>
);
}
```

위를 보면 알겠지만 상위 컴포넌트에서 넣어준 prop은 절대 자동으로 하위 컴포넌트로 가는 것이 아니라 꼭 불러야지만 return 값에 추가가 된다는 것을 기억해야 한다. 그래야지만 버튼을 눌렀을 때의 text가 Revert Changes로 변경 된다는 것이다.

**React.memo**

---

위의 소스를 보면 첫번째 Save Changes 버튼을 눌렀을 때 이 버튼은 리랜더링이 필요한 것이 분명하지만 밑에 Confirm 버튼은 변경 되는 사항이 없기에 굳이 리랜더링을 할 필요 없으나 실행을 해보면 React 규칙에 의해 두 컴포넌트 전부 리랜더링이 된다.

이를 방지하기 위해 우리는  React Memo라는 것을 할 수 있으며 이는 이 컴포넌트가 props가 변경되지 않았다는 가정 하에 다시 그려지는 것을 원치 않는다고 react에게 말해줄 수 있다.

```jsx
// 부모 컴포넌트
const MemorizedBtn = React.memo(Btn)
// 리액트 메모를 호출하고, 하위 컴포넌트 명을 담아줌.
function App(){
	const [value, setValue] = React.useState("Save Changes");
	const changeValue = () => setValue("Revert Changes");
	return (
		<div>	
			<MemorizedBtn text={value} onClick={changeValue}/>
			<MemorizedBtn text="Confirm"/>
			// 상위 컴포넌트 명을 메모를 담은 변수명으로 변경 해준다.
		</div>
);
}
```

이는 하나의 부모 컴포넌트에 엄청나게 많은 자식 컴포넌트가 포함 되어 있다고 가정했을 때 하위 컴포넌트 하나의 리랜더링 때문에 전체 컴포넌트가 전부 싹다 리랜더링 되면서  앱이 느려지는 현상을 방지할 수 있다.

**Prop Types**

---

Prop Types는 협업을 하는 과정이나 추후에 유지보수를 하게 될 때 내가 만들었던 상위 컴포넌트의 prop의 값에 넣어서는 안 되는, 설계와는 다른 종류의 값을 (String인데 boolen을 넣는 다거나) 넣게 되는 리스크를 없애기 위해 필요한 것이다.

 

prop types를 이용하기 위해선 먼저 설치가 필요한데 script 태그를 하나 더 만들고 경로를 추가 해주어야 한다.

https://unpkg.com/prop-types@15.7.2/prop-types.js

(위가 적용이 안 된다면 아래 것 중 하나 혹은 공식 사이트에서 찾아 보시길)

https://unpkg.com/react@17.0.2/umd/react.production.min.js

https://unpkg.com/react@17.0.2/umd/react.development.js

위를 설치 했다면 아래와 같은 것이 가능하다.

```jsx

Btn.propTypes = {
	text: PropTypes.string,
	fontSize: PropTypes.number
};
// 어떤 이름으로, 어떤 type의 값이 들어가야 되는지 설정 해준다.

// 부모 컴포넌트
function App(){
	return (
		<div>	
			<Btn text="String만 가능" fontSize={18}/>
			<Btn text={0} fontSize="이건 둘다 오류"/>
			// 위 Btn은 정상적으로 값이 들어가지만 밑 Btn은 오류가 난다.
			// (interprter라 오류 까지는 아니고 최소한 경고문구는 확인 가능하다.)
		</div>
);
}
```

만약 위에서 컴포넌트에 들어갈 prop을 정확히 지정하여 필수로 넣어야 되길 원한다면

```jsx
Btn.propTypes = {
	text: PropTypes.string.isRequired,
	fontSize: PropTypes.number.isRequired
};
```

.isRequired를 붙혀주면 된다. 이렇게 하면 text나 fontSize 둘 중 하나만 prop으로 넣지 않더라도 그건 경고문구가 확인 될 것이다.

이는 단순히 오류를 방지하는 것을 넘어서 협업을 하는데에 있어서 컴포넌트에 들어갈 prop의 속성을 정의 해놓아 타인이 이해하기 쉽다는 점에서도 매력적인 것 같다.

아래는 자식 컴포넌트에 대한 얘기다.

```jsx
// 자식 컴포넌트
function Btn({text, fontSize = 20}){
	return <button
			onclick = {onClick}
			style={{
					fontSize,
					속성,
					속성
				}}
		>props.text</button>;
}
```

위 처럼 props 인자에 값을 넣어주면 기본 값으로 설정 되는데 이는 상위 컴포넌트에서 자식 컴포넌트를 부를 때 따로 값을 넣지 않은 상태일 경우 저 20이라는 값을 사용 해주는 기본 Js 문법이다.

[PropTypes와 함께 하는 타입 검사 - React](https://ko.reactjs.org/docs/typechecking-with-proptypes.html)

prop-types의 다양한 유형은 위 페이지를 통해 확인 가능하다.