버튼을 클릭할 때 마다 카운트가 올라가는 기능을 구현하려면

```jsx
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src=" https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
    
		<script type="text/babel">
      const root = document.getElementById("root");
      let counter = 0;
      function countUp() {
        counter += 1;
      }
      const Container = () => (
        <div>
          <h3>누른 횟수: {counter}</h3>
          <button onClick={countUp}>눌러라</button>
        </div>
      );

      ReactDOM.render(<Container />, root);
    </script>
  </body>
```

이런 형식이 된다.

함수나 변수를 html 요소에 넣기 위해서 {}를 사용한다.

하지만 이는 웹사이트에 보이긴 하지만 클릭을 했을 때 카운트가 올라가지 않는다.

위 type=”text/babel” script에 있는 소스 중 페이지 접속시 바로 실행 되는 것은 ReactDOM.render 밖에 없다. 나머지는 전부 함수 형태이기 때문에

그리고 그 render의 내용은 Container 함수를 불러서 안에 있는 내용을 Html 요소로 만들어서 root로 보내줄거야 이고 이때 counter의 값은 0이다.

또한 onClick으로 이벤트를 감지하여 버튼을 클릭 했을 때 counter의 값을 1씩 올려준다.

문제는 위의 있는 코드 어디에서도 UI를 새로고침 해주고 있지 않다는 것이다. 더 풀어 말하자면Container를 딱 한번 사이트 접속 시 랜더링 해줬을 뿐 다시 리렌더링 하고 있지 않다는 것이다.

그러니까 우리는

```jsx
function countUp() {
	counter += 1;
	ReactDOM.render(<Container />, root);
}
```

이와 같이 이벤트로 인하여 html 요소 중 무언가의 변화가 일어 났을 때 이를 이용자에게 다시 보여줄 수 있게끔 리렌더링을 해줘야 한다.

근데 아마 저 rnder는 많이 쓰일테니 따로 함수를 하나 만드는게 좋을 것이다.

위의 내용이 단순히 일반 Js로 빌드한 웹사이트 보다 소스가 줄어서 간편하다 정도로 그치는 것이 아니고 구조적인 장점이 있는데

일반 Js 같은 경우 노드 정보가 바뀔 때 마다 노드 트리를 5단계에 걸쳐 처음 부터 다시(모든 html요소를) 재생성하게 되는데 리액트의 경우 가상돔을 써서 이용자에게 보여지는 부분만 수정해서 보여주며 모든 업뎃이 끝나면 일괄로 합쳐서 실제 돔에 던져 준다고 한다.

쉽게 말하자면 Js는 위와 같은 기능을 구현할 시 버튼을 눌렀을 때 버튼 뿐만 아니라 버튼을 포함한 모든 상위 객체를 전부 업데이트 하지만 react 같은 경우 바뀐 부분만 체크하여 h3에 들어있는 counter의 숫자 부분만 정확히 콕 집어서 업데이트 하기 때문에 구조적으로 매우 이점이 강하다고 볼 수 있다.

다만 위 방법은 리렌더링을 하기 위한 최적의 방법은 아니다. 매번 리렌더링 하는 것을 잊으면 안 되기 때문이다. 이에 대한 가장 좋은 방법은 다음 글에서 알아볼 것이다.