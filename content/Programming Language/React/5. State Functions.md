```jsx
<script type="text/babel">
      const root = document.getElementById("root");

      function App() {
        const [counter, modifier] = React.useState(0);
        const onClick = () => {
          modifier(counter + 1);
        };
        return (
          <div>
            <h3>누른 횟수: {counter}</h3>
            <button onClick={onClick}>눌러라</button>
          </div>
        );
      }

      ReactDOM.render(<App />, root);
    </script>

```

위 소스는 버튼을 클릭했을 때 counter를 1 올리고 리렌더링 해라라는 의미인데 이 과정에서 어디선가 counter의 값이 건드려져 내가 의도했던 값이 아닌 이상한 값이 튀어나오는 버그가 생길 수 있다는 점에서 그렇게 좋은 방법은 아니다.

state를 설정하는 방법 중 하나가 modifier(1234) 이런식으로 괄호안에 값을 직접 넣어 새 값으로 변경 해주는 것이며 이는 글자도 가능하다. 

그리고 이전 값을 이용해서 현재 값을 계산하는 방법이 지금 위 소스의 방법인데 구조상 위와 같은 방법이지만 더 나은 방법이 존재한다.

```jsx
const onClick = () => {
	modifier(counter + 1);
};
// 이 onClick에서 modifier에 넣을 값을 함수로 고쳐줄 것이다.
const onClick = () => {
	modifier((current) => current + 1);
};
// 이 modifier에는 함수를 넣을 수 있고 함수의 첫 번째 argument는 현재 값이며 이 함수의
// return 값이 새로운 state가 되는 것이다.
```

사실 위와 아래 것의 동작은 같은 것이다. 다만 아래 방법이 좀 더 안전하다고 할 수 있는 것은 리액트가 이 current가 확실히 현재 값이라는 것을 보장하고 있기 때문이다.