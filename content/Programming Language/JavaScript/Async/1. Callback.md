js는 동기적인(synchronous) 언어이다.

이 말은 hoisting이 된 이후 부터 코드가 우리가 작성한 순서에 맞춰서 하나씩 동기적으로 실행된다는 말이다.

그렇다면 hoisting은 무엇인가

hoisting은 함수, 변수 등의 선언들이 가장 위로 올라가는 것을 말한다.

그렇다면 비동기(asynchronous, 줄여서 async)는 무엇인가

async는 언제 코드가 실행될지 예측할 수 없는 것을 말한다.

가장 좋은 예시로는 브라우저에서 제공되는 api인 setTimeout이 있다.

```jsx
console.log('1');
setTimeout(() => console.log('2'), 1000);
console.log('3');
//1, 3이 콘솔창에 찍힌 뒤에 2가 찍힌다.
```

위 처럼 setTimeout은 지정한 시간이 지나면 콜백함수를 불러주는 역할을 한다.

(setTimeout에 들어있는 함수는 바로 실행되는 것이 아니라 나중에 니가 불러줘, Call back 해줘 하고 전달해준 것이다.)

그렇기에 콜백함수는 우리가 전달 해준 함수를 나중에 불러달라는 개념이다.

그럼 callback은 항상 비동기일 때만 사용 할까?

아니다.

이런 콜백함수에도 Synchronous callback, Asynchronous callback 2가지 경우가 존재한다.

**Synchronous callback**

- 즉각적으로 (동기적으로) 실행하는 콜백

**Asynchronous callback**

- 나중에, 언제 실행될 지 예측할 수 없는 콜백

콜백을 파라메터 인자로 받아서 처리하는 함수를 만들어보자.

```jsx
console.log("1");
setTimeout(() => console.log("2"), 1000);
console.log("3");

// **Synchronous callback**
function printImmediately(print) {
  print();
}
printImmediately(() => console.log("hello"));

// **Asynchronous callback**
function printWithDelay(print, timeout) {
  setTimeout(print, timeout);
}

printWithDelay(() => console.log("async callback"), 2000);

// 실행 시 1, 3, hello, 2, async callback 순서로 출력된다.
```

이 예제 코드를 보면서 다시 한번 typeScript의 필요성을 느꼈다.

위 코드에서 printImmediately와 printWithDelay 두 함수를 호출할 때 인자로 사용하는 console.log()가 callback 함수인 것이며 둘은 호출 시 바로 실행 되고(**Synchronous)** 안 되고(**Asynchronous)**의 차이가 있다.

또한 어떠한 이벤트가 발생했을 때 호출되어지는 함수도 callback 함수라고 부른다.

callback을 다루는 방식은 언어 마다 다르며 포인터, 서브루틴, 람다함수의 형태로 넘겨준다.

그리고 이러한 콜백함수는 유용한 형태로 쓰일 수 있지만

콜백함수 안에서 콜백함수를 부르고 부르고 부르고 부르고 부르는 콜백지옥을 만드는 경우가 발생하기도 한다.

![Untitled](images/JavaScript/Untitled%2039.png)

이런 콜백지옥의 문제는 일단 읽기 부터가 거북하고 비즈니스 로직을 한눈에 이해하기도 어렵다.

이런 콜백을 대체할 수 있는 Promise를 다음 페이지에서 알아볼 것이다.