Promise는 Js에서 제공하는 콜백함수 대신 **비동기를 간편하게** 처리할 수 있도록 도와주는 오브젝트이다.

정해진 시간의 기능을 수행하고 나서 정상적으로 기능이 작동 됬다면 성공의 메세지와 함께 처리된 결과 값을 전달해주며 예상치 못한 오류가 발생했다면 에러를 전달해준다.

개념 이해를 위해 2가지의 포인트를 잡으면 된다.

1. 기능 수행 중인지 혹은 기능을 완료 했는지, 실패 했는지의 State
2. 정보를 제공하는 Producer와 정보를 소비하는 Consumer

---

- **Producer**

```jsx
const promise = new Promise((resolve, reject) =>{
// Promise는 Object임으로 new를 사용하여 생성하며 executor라는 콜백함수를 전달해줘야 한다.
// executor는 resolve(기능 수행 시 호출할 함수)와 reject(문제 발생 시 호출할 함수)라는 콜백함수를 받는다.
});
```

기본적인 Promise의 생성 형태이다.

Promise 안에서는 보통 무거운 작업들을 하게 되는데 이는

네트워크에서 데이터를 받아오거나 DB에서 무언가 큰 데이터를 읽어오는 과정은 시간이 꽤 소요되고 이를 동기적으로 처리하게 될 경우 이 시간 동안 다음 라인의 코드가 실행되지 않기 때문에 Promise로 비동기적으로 처리하는 것이 좋기 때문이다.

```jsx
const promise = new Promise((resolve, reject) =>{
    console.log('loglog');
});
```

위 처럼 작성한 executor로 전달한 콜백함수는 Promise를 생성하자마자 바로 실행된다.

(어떤 이벤트 발생 시 콜백함수를 실행하고자 한다면 이 점을 유의해야 한다.)

```jsx
const promise = new Promise((resolve, reject) =>{
    무언가 DB에 요청함.
		resolve('요청해서 얻은 값 잘라서 줘');
});
```

그리고 위 처럼 어떤 작업을 한 다음 resolve라는 콜백함수를 통해 받아올 값을 어떻게 받을 것인지 전달하면 된다.

---

- **Consumers**

Consumers에는 then, catch, finally 3 종류가 있다.

```jsx
const promise = new Promise((resolve, reject) => {
  대충 DB 조회하는 소스
  resolve("전처리된 DB 정보");
	reject('에러 발생'))
});

// 값이 정상적으로 잘 수행이 된다면 이라는 뜻
promise.then((value) => {
  //value는 resolve에서 뱉어낸 값
  console.log(value);
})
.catch(error =>{
	// error 또한 reject에서 뱉어낸 값
    console.log(error);
})
.finally(() =>{
    console.log('finnally');
});

```

위 처럼 하면 loglog가 찍히고 뭐가 찍힐 것이다.

저 .catch가 무슨 개같은 코드인가 싶겠다만 promise.then의 then이 사용했던 promise와 똑같은 promise를 return 하기 때문에 가능한 문법이고 이를 chaining이라고 한다.

finally는 우리가 잘 아는 그 finally가 맞다. 성공하든 실패하든 호출되는 것이다.

![Untitled](Untitled%2040.png)

위 처럼 연광성있는 여러 Promise를 생성해 놓은 다음 then.then.then 이렇게 연결도 가능하다.

then 사이에 catch도 물론 이용 가능하다.

그리고 getHen()을 호출한 곳을 보면 함수가 일반적인 형태로 들어있지 않은데 resolve로 return되는 값이 하나이고 오직 그 값만 인자로 사용하는 함수를 호출하는 것이라면 위 문법처럼 생략이 가능하다.