 
# 파일과 디렉토리

>파일 시스템은 운영체제의 기능 중 하나이며 파일과 디렉터리를 관리하는 기능이다.
보조기억장치에 있는 데이터 덩어리일 뿐인 파일과 디렉터리를 파일시스템은 어떻게 관리할까?

## 파일

파일은 보조기억장치에 저장된 관련 정보의 집합을 의미, 달리 표현하면 파일은 의미 있고 관련 있는 정보를 모은 논리적 단위를 의미한다.

파일에는 여러 정보가 있다.
- 파일의 이름
- 파일을 실행하기 위한 정보
- **파일 관련 부가 정보**(파일 속성 혹은 메타데이터라 부름)
- (윈도우에서 파일을 우클릭하고 속성을 클릭했을 때 확인되는 정보가 바로 파일 속성)

파일 속성에도 다양한 종류가 있다.
- **유형**
- 크기
- 보호 -> 파일 권한을 의미
- 생성 날짜
- 접근 날짜
- 수정 날짜
- 생성자
- 소유자
- 위치

**파일 유형**은 운영체제가 인식하는 파일 종류를 말한다. 파일을 올바르게 실행하기 위해 운영체제에게 파일 유형을 알려주어야 하며 이때 흔히 쓰이는 방식이 **확장자**이다.

파일 유형은 다음과 같이 나뉜다.
- 실행 파일(확장자 없음, exe, com, bin)
- 목적 파일(obj, o)
- 원시 파일(c, cpp, cc, java, asm, py)
- 워드 프로세서 파일(xml, rtf, doc, docx)
- 라이브러리 파일(lib, a, so, dll)
- 멀티미디어 파일(mpeg, mov, mp3, mp4, avi)
- 백업/보관 파일(rar, zip, tar)

모든 응용프로그램은 임의로 파일을 조작할 수 없으며 파일을 다루려면 **시스템 호출**을 통해 운영체제에게 부탁해야 한다. 

파일 연산을 위한 **시스템 호출**의 종류는 다음과 같다.
- 파일 생성
- 파일 삭제
- 파일 열기
- 파일 닫기
- 파일 읽기
- 파일 쓰기

## 디렉토리

파일을 일목요연하게 관리하기 위한 것. 윈도우에서는 폴더라고 부른다.

예전에는 모든 파일이 한개의 디렉토리에 있는 1단계 디렉토리 구조가 사용 되었으나
현재는 최상위 디렉토리(루트 디렉토리) 아래로 여러 서브 디렉토리가 생성되는 방식이다.
서브 디렉토리가 생기면서 같이 생겨난 개념이 경로(path)다.

**절대 경로**
최상위 디렉토리에서 부터의 경로

**상대 경로**
현재 디렉토리에서 부터의 경로
현재 디렉토리 - .
현재 디렉토리의 상위 디렉토리 - ..

디렉토리도 파일 처럼 운영체제를 통해 시스템 호출로 연산이 가능하다.
디렉토리 연사을 위한 시스템 호출의 종류는 다음과 같다.
- 디렉토리 생성
- 디렉토리 삭제
- 디렉토리 열기
- 디렉토리 닫기
- 디렉토리 읽기

**디렉토리**는 사실 파일과 구별되는 별개의 존재가 아니라
내부에 포함하고 있는 **파일의 정보를 테이블 형태로 담고 있는 하나의 파일**이다.

파일시스템마다 차이가 있으나 디렉터리 엔트리(행)가 담고 있는 공통된 정보가 있다.

Home 디렉토리 테이블

| 파일 이름   | 위치 정보   |
| ------- | ------- |
| ..      | 상위 디렉토리 |
| .       | 현재 디렉토리 |
| log.txt | 어딘가     |
| a_dir   | 어딘가     |

a_dir 디렉토리 테이블

| 파일 이름  | 위치 정보     |
| ------ | --------- |
| ..     | Home 디렉토리 |
| .      | 현재 디렉토리   |
| ff.bin | 어딘가       |
| b_dir  | 어딘가       |

위 같이 파일의 이름과 그 파일의 위치를 유추할 수 있는 정보는 항상 포함되어있다.
테이블끼리 연결되어있다고 보면 된다.

# 파일 시스템

>파일과 디렉토리가 보조기억장치에 어떻게 저장되고 접근하는지 알아보자.

## 파티셔닝과 포매팅

우리가 방금 막 생성한, 사용된 적이 없는 새 보조기억장치를 사용한다고 했을 때 곧바로 파일을 생성하거나 저장할 수 없다. 보조기억장치를 사용하려면 파티션을 나누는작업(파티셔닝)과 포맷 작업(포매팅)을 거쳐야하기 때문이다.

### 파티셔닝

저장 장치의 논리적인 영역을 구획하는 작업.
커다란 서랍안의 물건을 칸막이를 설치하여 영역을 나누고 물건을 분류하는 것과 비슷하다.
영역을 나누는 작업을 **파티셔닝**이라 하며 나누어진 영역 하나하나를 **파티션**이라고 한다.

윈도우에서 파티셔닝을 보려면 *하드 디스크 파티션 만들기 및 포맷*을 검색하면 된다.

### 포매팅

포맷 작업은 정확히는 저장 장치의 데이터를 날리는 작업이 아니다.
어떤 파일 시스템을 사용할지 설정하고 어떤 방식으로 파일을 저장, 관리할 것인지 결정하는 작업.
새로운 데이터를 쓸 준비를 하는 작업을 의미한다.

엄밀히 말하면
**저수준 포매팅**(공장에서 저장 장치를 생성할 당시에 수행되는 물리적인 포매팅)과
**논리적 포매팅**(지금 설명하는 파일 시스템을 생성하는 포매팅)으로 나뉜다.

이러한 파일 시스템에는 여러 종류가 있으며 파티션 마다 설정할 수도 있다.

## 파일 할당 방법

운영체제는 파일과 디렉토리를 **블록** 단위로 읽고 쓴다. 즉, 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장된다. **섹터**라는 더 작은 단위가 있으나 개수가 너무 많고 크기가 작아 하나 이상의 섹터를 블록이라는 단위로 묶어 관리한다.

----------------
하드 디스크

[0], [1], [2], [3], [4]
[5], [6], [7], [8], [9]
....

---

대괄호 하나가 블록이라고 생각하자. 블록에 적힌 번호는 블록의 위치를 식별하는 주소이다. 이 블록에 파일을 할당해야 하는데 크기가 작으면 적은 수의 블록에 걸쳐 저장디고 크기가 크면 여러 블록에 걸쳐 저장될 것이다.

이러한 상황에서 파일을 보조기억장치에 할당하는 방법은 크게 두가지가 있다.
**연속 할당**과 **불연속 할당**이다.  또 불연속 할당에는 크게 **연결 할당**, **색인 할당**이 있다.

### 연속 할당

연속 할당은 가장 단순한 방식이다. 이름 그대로 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식이다. 

a 파일은 블록을 3개 b 파일은 블록을 2개 c 파일은 블록을 5개 사용한다고 했을 때
다음과 같이 연속적으로 할당되는 방식이다.

----------------
하드 디스크

[a], [a], [a], [b], [b]
[c], [c], [c], [c], [c]
[10], [11], [12], [13], [14]
...

---

따라서 연속으로 할당된 **파일에 접근하기 위해**서는 파일의 **첫 번째 블록 주소**와 **블록 단위의 길이**만 알면 된다. 그렇기에 연속할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에도 파일 이름과 첫 번째 블록 주소, 블록 길이를 명시한다.

연속 할당 방식은 구현이 단순하다는 장점이 있으나 **외부 단편화**를 야기하는 치명적인 문제가 존재한다.

 a, b, c 파일을 일렬로 느려뜨렸을 때 b 파일을 삭제 하면
 
---
[a], [a], [a], [b], [b], [c], [c], [c], [c], [c], [10], [11], [12], ...

[a], [a], [a], [ ], [ ], [c], [c], [c], [c], [c], [10], [11], [12], ...

---
위 처럼 a와 c 파일 사이에 빈 블록 2개가 생기게 되고 저 공간에는 앞으로 블록을 3개 이상 쓰는 파일은 저장할 수 없게 된다. 이것을 외부 단편화라고 한다.

### 연결 할당

연속 할당의 문제를 해결할 수 있는 방식이 연결 할당이다. 연결 할당은 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식이다.
즉, 파일을 이루는 데이터를 연결 리스트로 관리한다.

![[images/filesystem/1.png]]
블록에 다음 블록의 주소를 갖고 있고 마지막 블록에는 다음 블록이 없다는 특별한 표시자를 기록한다. 그렇기 때문에 연결 할당의 디렉터리 엔트리에는 연속 할당과 마찬가지로 **파일 이름**, **첫 번째 블록 주소**, **블록 단위의 길이**를 명시한다.

연결 할당의 단점
- 반드시 첫 번째 블록 부터 하나씩 차례대로 읽어야 한다.
  특정 파일에 임의의 위치에 접근하는 임의 접근 속도가 매우 느리다. 특정 파일의 i번째 블록에 접근하기 위해서는 항상 첫 번째 블록 부터 i번째 블록까지 순차적으로 접근 해야만 한다.

- 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.
  하드웨어에 고장이나 오류로 인해 파일을 이루는 블록에 하나라도 문제가 발생한다면 문제가 발생한 그 블록 이후의 블록에는 접근할 수가 없다.

### 색인 할당

색인 할당은 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식이다.
색인 블록에 모든 블록 주소가 담겨있기에 색인 블록 위치만 알고 있으면 모든 데이터 블록에 쉽게 접근이 가능하다. 그렇기에 연결 할당과 다르게 임의 접근이 쉽게 가능하다. 
디렉토리 엔트리에는 **파일 이름**과 **색인 블록 주소**를 명시한다.

![[images/filesystem/2.png]]
이러한 색인 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템이다.

## 대표적인 파일 시스템

>파일 시스템에는 다양한 종류가 있지만 여러 전공서에서 공통으로 소개하는 파일 시스템은 크게 두가지다. USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 FAT 파일 시스템과 유닉스 계열 운영체제에서 사용되는 유닉스 파일 시스템이다.

### FAT 파일 시스템

연결 할당의 단점을 보완한 파일 시스템이 FAT 파일 시스템이다.
연결 할당 방식의 단점의 근본적인 원인은 블록 안에 다음 블록의 주소를 저장했기 때문이다.

FAT 파일 시스템은 이러한 각 블록에 포함된 다음 블록의 주소들을 한데 모아 데이블 형태로 관리하는 파일 시스템이다. 이러한 테이블을 파일 할당 테이블, **FAT (File Allocation Table)** 이라고 부른다.

| 블록 주소 | 다음 블록 주소 |
| ----- | -------- |
| 0     |          |
| 1     |          |
| 2     |          |
| 3     | 5        |
| 4     | 8        |
| 5     | -1       |
| 6     |          |
| 7     |          |
| 8     | 3        |
| 9     |          |

FAT 파일 시스템은 버전에 따라 FAT12, FAT16, FAT32가 있고 뒤에 오는 숫자는 블록을 표현하는 비트 수를 의미한다. 이러한 FAT 파일 시스템은 옛날 마이크로소프트의 운영체제인 MS-DOS에서도 사용되었고 최근까지도 USB, SD 카드 같은 정용량 저장 장치용 파일 시스템으로 사용되고 있다.
(윈도우에서는 블록 대신 클러스터라고 한다.)

FAT 파일 시스템에서 FAT는 파티션의 앞부분에 만들어진다. 하드디스크의 한 파티션을 FAT 파일 시스템으로 포맷하면 파티션이 다음과 같이 구성된다.

![[images/filesystem/3.png]]

FAT는 하드 디스크 파티션의 시작 부분에 있으나 **메모리에 캐시**될 수 있다. 캐시된 경우 기존 연결 할당 보다 다음 블록을 찾는 속도가 매우 빨라지며 임의 접근에도 유리해진다. 즉, **기존 연결 할당의 단점이 개선**된다.

FAT 파일시스템의 디렉터리 엔트리에는 다음과 같은 정보가 담겨있다.

- 파일 이름
- 확장자
- 속성
- 예약 영역
- 생성 시간
- 마지막 접근 시간
- 마지막 수정 시간
- 시작 블록
- 파일 크기

>속성 영역은 읽기 전용 파일, 숨김 파일, 시스템 파일, 일반 파일을 식별하기 위한 항목이다.

### 유닉스 파일 시스템

유닉스 파일 시스템은 색인 할당을 기반으로 한다. 색인 할당은 색인 블록을 기반으로 파일의 데이터 블록들을 찾는 방식이며 유닉스 파일 시스템에서는 이 **색인 블록을 i-node**라고 부른다.

i-node에는 파일 속성 정보와 15개의 블록 주소가 저장될 수 있다. FAT 파일 시스템에서는 파일 속성 정보가 디렉터리 엔트리에 표현되었으나 유닉스 파일 시스템은 i-node에 표현된다.

이러한 i-node는 파일마다 있으며 번호가 부여된다. 그리고 i-node 들은 다음과 같이 파티션 내 특정 영역에 모여 있다.
![[4.png]]

i-node는 15개의 블록을 저장할 수 있다는 것은 크기가 유한하다는 말. 즉, 15개 이상의 블록을 차지하는 파일은 i-node 하나 만으로는 파일의 모든 데이터 블록을 가리킬 수 없다.

유닉스 파일 시스템은 이러한 문제를 다음과 같이 해결한다.

1. 블록 주소 중 열두 개에는 직접 블록 주소를 저장한다.
   
   파일 데이터가 저장된 블록을 **직접 블록**이라고 하며 i-node의 12개 주소에는 이 직접 블록 주소를 저장한다. 이것만으로파일 데이터 블록을 모두 가리킬 수 있다면 추가적인 작업이 필요하지 않다.
   
2. 위 내용으로 충분하지 않다면 열세 번째 주소에 단일 간접 블록 주소를 저장한다.
   
   단일 간접 블록은 파일 데이터가 저장된 **블록이 아닌** 파일 데이터를 저장한 **블록 주소가 저장된 블록**을 의미한다.
   
3. 위 내용으로도 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장한다.
   
   이중 간접 블록은 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미한다. 즉, **단일 간접 블록들의 주소를 저장**하는 블록이 이중 간접 블록이다.
   
4. 위 내용으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장한다.
   
   삼중 간접 블록은 **이중 간접 블록 주소가 저장된 블록**이다.
   삼중 간접 블록까지 이용하면 웬만한 크기의 파일은 모두 표현할 수 있다.

아래 사진과 같은 형태다.

![[5.png]]

i-node만 알면 파일 속성뿐만 아니라 파일 크기가 크더라도 파일 데이터를 모두 가리킬 수 있다. 그렇기에 유닉스 파일 시스템의 **디렉터리 엔트리**도 **파일 이름**과 **i-node 번호**로 구성된다.

파일 시스템은 종류가 많으며 이를 아우르는 개념은 방대하다. 파일 시스템만을 다루는 전공서도 많다고 한다. 대표적인 파일 시스템 두가지를 알아보았으나 다음 두개에 대해서도 알아두면 좋을 것 같다.

윈도우 운영체제 - NT 파일 시스템(NTFS)
리눅스 운영체제 - ext 파일 시스템

https://github.com/kangtegong/self-learning-cs/blob/main/file_system/file_system.md
