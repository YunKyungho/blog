우선 Git이 뭔지 정확하게 알고 넘어가자.

  

Git은 분산형 버전 관리 시스템(VCS)이다.

  

버전 관리 시스템의 종류도 여러개고 종류마다 여러 S/W가 있다. (아래 나무 위키를 참고하자.)  
[버전 관리 시스템 나무위키](https://namu.wiki/w/%EB%B2%84%EC%A0%84%20%EA%B4%80%EB%A6%AC%20%EC%8B%9C%EC%8A%A4%ED%85%9C)﻿

  

> 오픈소스계의 영원한 아이돌 리누스 토르발스는 리눅스 커널을 관리하는 기존 툴이 엉망인 것에 너무 빡친 바람에 Git이라는 소스관리 툴을 만든다. 리누스는 하도 빡친 나머지, 단 2주만에 완성하는 기염을 토했다.   
> [원문 링크(이 분 블로그에 상당히 좋은 포스팅들이 많다.)](https://sangminpark.blog/2013/04/22/%ec%98%a4%ed%94%88%ec%86%8c%ec%8a%a4%ec%9d%98-%ec%8a%b9%eb%a6%ac/)

라는 개발 비화를 가지고 있다. 아무리 생각해도 참 대단하신 분이다. 2주만에 만든 툴이 전 세계 최고의 점유율이 되다니..

  

본문도 나무위키를 읽고 요약한 수준이기에 시간 낭비라고 생각하면 뒤로가기를 눌러주시기 바란다.

(필자는 배경 지식이 전혀 없는 어떤 분야에 대해 처음 정보를 수집할 때 나무위키만한 것이 없다고 생각한다.)

  

> 목차  
> [1. 왜 버전 관리 툴을 사용하는가?](https://bad-head-suffer-finger.tistory.com/manage/newpost/5?type=post&returnURL=https%3A%2F%2Fbad-head-suffer-finger.tistory.com%2Fmanage%2Fposts%3Fcategory%3D-3%26page%3D2%26searchKeyword%3D%26searchType%3Dtitle%26visibility%3Dall#c1)  
> [2. 분산형 버전 관리 시스템(VCS)이란?](https://bad-head-suffer-finger.tistory.com/manage/newpost/5?type=post&returnURL=https%3A%2F%2Fbad-head-suffer-finger.tistory.com%2Fmanage%2Fposts%3Fcategory%3D-3%26page%3D2%26searchKeyword%3D%26searchType%3Dtitle%26visibility%3Dall#c2)  
> [3. Git의 장/단점](https://bad-head-suffer-finger.tistory.com/manage/newpost/5?type=post&returnURL=https%3A%2F%2Fbad-head-suffer-finger.tistory.com%2Fmanage%2Fposts%3Fcategory%3D-3%26page%3D2%26searchKeyword%3D%26searchType%3Dtitle%26visibility%3Dall#c3)>  
> [4. 느낀점](https://bad-head-suffer-finger.tistory.com/manage/newpost/5?type=post&returnURL=https%3A%2F%2Fbad-head-suffer-finger.tistory.com%2Fmanage%2Fposts%3Fcategory%3D-3%26page%3D2%26searchKeyword%3D%26searchType%3Dtitle%26visibility%3Dall#c4)

---

  

  

**왜 버전 관리 툴을 사용하는가?**

- 변경점 관리: 어떤 내용을 누가 작성해서 어느 시점에 들어갔는지 확인할 수 있게 해준다.
    
- 버전 관리: 특정 시점에 꼬리표(Tag)를 달아 버전을 표시해주고  
    브랜치(Branch) 등으로 동시에 여러 버전을 개발할 수 있게 해준다.
    
- 복구: 무언가가 잘못되었을 때 다시 특정 시점으로 돌아가게 해주고, 사고로 내용이 날아간 경우에도 복구할 수 있게 해준다.
    
- 협업: 같이 일하는 사람들에게 수정사항을 쉽게 공유한다.
    

음 회사에서도 확실히 Git을 통해 위 이점들을 챙기고 있다.

  

  

  

**분산형 버전 관리 시스템(VCS)이란?**

  

Git을 써봤다면 알겠지만 어떤 프로젝트를 pull 했을 때 해당 프로젝트의 모든 파일(데이터)들이 전부 나의 로컬 PC의 지정한 작업 폴더에 저장되는 것을 볼 수 있다. 이는 여러 작업자들이 전부 개별적으로 프로젝트를 저장하고 있다는 말이다.

고로 하나의 중앙 서버에만 프로젝트가 존재하는 것이 아니기에 분산형인 것이다. 이는 좀더 유동적이고 안전한 협업과 버전관리를 가능하게 한다.

  

  

  

**Git의 장/단점**

  

> **장점  
> **

  

- **오프라인 작업이 가능하다.**  
    기존 중앙집중형 형상관리 툴은 작업자의 특정 파일 체크아웃이 실시간으로 서버에 드러나야 하기 때문에 오프라인 작업이 불가한반면에(되더라도 추가적인 형상관리가 안 된다.) git은 로컬 저장소에 있는 히스토리가 그대로 유지되므로 서버에서 새 자료를 받아올 수 없을 뿐이지 이외에는 오프라인 상태에서도 대부분의 형상관리 기능을 이용할 수 있다. (일종의 로컬 서버로 작용하는 셈이라고 한다.) 비슷한 맥락으로 일시적인 서버 장애가 있어도 개발을 계속할 수 있다.  
      
    
- **속도가 빠르다.  
    **각각의 개발자들이 모두 분산처리 서버의 주인이 되는 셈이므로 서버가 직접 해야 될 일들이 많이 줄어든다.  
      
    
- **분산처리 구조를 유연하게 세울 수 있다.  
    **중간 서버, 부서별 서버를 둔다든지 하는 구성이 자유롭게 가능하다.  
      
    
- **가지치기(branch)가 비교적 가볍다.  
    **가지치기는 대부분의 형상관리 도구가 지원하는 기능이다만 실질적인 차이는 그 구현 방법에 있다고 한다. git은 브랜칭이 매우 쉽고 가벼워 원하는 만큼 별 제약 없이 생성하고 삭제할 수가 있다. (기존 형상관리 도구를 사용하던 사람들은 브랜칭 하나 하려고 수 시간의 미팅을 해야 하던 때도 있었다고 한다.)  
      
    
- **병합(merge)에서 문제가 덜 발생한다.  
    **서버의 자료를 가져와(fetch) 로컬에서 병합하고 이를 다시 올리는 형태이기 때문에 예기치 못하게 발생하는 병합 문제 발생 빈도가 낮아진다. (물론 아예 문제가 발생하지 않을 수는 없다.)  
      
    
- **스테이징을 지원한다.  
    **커밋전 커밋을 원하는 변동내역만 선택하는 스테이징 단계가 따로 있다.   
      
    
- 직접 호스팅을 할 경우 상업용 용도로도 무료로 이용 가능한 방법이 존재한다.  
      
    
- 수많은 개발자용 툴이 Git을 자체 지원하거나, Git용 플러그인이 있다. 또한 관련 툴킷 범위도 넓어, 초보자를 위한 GUI부터 전문자용 Diff툴까지 Git사용에 도움이 되는 툴이 많다. 또한 [libgit2](https://github.com/libgit2/libgit2) 등을 이용하면 원하는 언어로 Git을 활용하는 프로그램을 직접 만들 수도 있다.(오 직접 만들기 재밌을 것 같다.)
    

  

> **단점**

- **기존 형상관리 도구에 비해 덜 직관적이고 배우기 어렵다.  
      
    로컬**(작업공간), **서버**(저장공간)으로 **단순한 구조**의 **중앙집중형 도구**에 비해 git은 작업 디렉토리 - 스테이징 공간 - 로컬 저장소 - 원격 저장소 라는 **다층 구조**를 가지고 있으며 각각의 맡은 역할과 다른 **계층과의 상호작용** 방식이 훨씬 **복잡하게 연결**된다. 또한 개념적인 가상 공간과 실제 물리적 저장소가 섞여 있어 혼동을 유발한다.  
      
    복잡한 구조 만큼 **명령어 또한 다양**하며 처음 배우는 경우 어디까지가 서버에 영향을 미치는 행위이고 어디까지가 로컬에서 안전하게 할 수 있는 일인지 명확하게 이해하기가 어려워 명령어 하나하나에 벌벌 떨게 된다.(정확히 내 얘기라 놀랐다.)  
      
    서버에 있는 자료와 로컬의 자료를 비교하여 커밋 후에 변화를 미리 명확하게 알 수 있는 **기존 형상관리에 비하면 덜 직관적**이다. 바로 이 문제 때문에 기존 형상관리 도구를 계속 사용하는 경우도 많다고 한다. 이 때문에 GUI를 이용한 작업 유형과 콘솔 명령어를 통한 작업 유형 둘 다 **쓰는 기능만** **반복**적으로 사용하는 경우가 많다.   
      
    
- **작업 계층 구조**(작업 내용 - 스테이징 공간 - 로컬 저장소 - 원격 저장소 등)에 대한 '**기능' 은 매우 명확**하게 만들어져 있고 그 **동작도 일정하지만**, 정작 이를 해석해서 추상화하는 **사람들의 해석과 설명이 제각각**인 경우가 많다. 단적으로 구글에 '**Git Workflow**'만 검색해 봐도, '알기 쉬운 도표' 들이 수없이 검색되지만 완전히 **똑같이 생긴 것이 없다**시피 할 정도다. 이 때문에 **'git에 익숙해진 사용자'** 는 스스로 각 명령어에 대해 체감적으로 이해하고 있고 손에 익어 사용하고 있다고 느끼지만, 정작 그것을 표현하려고 보면 각 **사용자끼리 표현방식이 일치하지 않는다.**  
      
    
- 한 번에 여러 브랜치나 여러 태그에 걸쳐서 커밋을 할 수 없다. 내가 만든 사소한 변동사항이 다른 브랜치에 자동적으로 알려지지 않고 취합하는 시점에 반영된다. 때에 따라선 이후 다른 브랜치와 병합하려 할 때 충돌의 원인이 될 수도 있다.  
      
    
- 하나의 저장소가 하나의 프로젝트 전체를 의미하는 것으로 강제되어 있어 일부만 브랜칭을 한다든지 클론을 한다든지 하는 일을 할 수 없다. 정책적인 부분이라 관점에 따라 장점이 될 수도 있겠지만, 해당 기능이 꼭 필요한 사람이라면 단점이 될 수 있다.  
      
    (위 두가지는 개인적으로 안전성을 위한 장치로 보인다. 협업에 있어서는 오히려 장점이 아닐까 싶다.)  
      
    
- push를 한 내용이라 하더라도 해당 브랜치가 다른 브랜치에 병합되기 전에 삭제돼버리면 나중에 해당 내용에 접근할 수 없기에 커밋 히스토리가 영원히 안전하게 저장된다고 장담할 수 없다.  
      
    
- 서버에 저장소를 두고 로컬 머신에서는 작업중인 프로젝트만을 두는 것이 설계개념상 불가능하다. 원격 저장소와 로컬 저장소를 모두 요구하기 때문에 저장소 전체를 받아서 작업해야 된다는 부분도 원하지 않는 경우 사용되는 용량면에서 단점이다.
    

  

---

**느낀점**

  

아직 배워야할게 한참 남았지만 깨달은 점이 있다. Git의 단점들을 보고있다 보니 왜 직장 상사분들이 Git은 어떻게 공부하냐는 질문에 하나같이 "쓰다보면 익숙해져요~"라고 하셨는지 이해가 간다. 어쩌면 Git 사용법뿐만아니라 Git 자체를 이해하려는 나의 시도는 무모한 짓일지도 모르겠다는 생각도 든다. 구직에 전념하며 구인 공고를 훑어볼 때 Git 전문가를 채용한다는 글을 본적이 있는데 당시엔 'Git이 전문가를 따로 뽑을 정도의 영역인가?'라는 생각을 했었는데 그럴만했네 ㅋㅋ.